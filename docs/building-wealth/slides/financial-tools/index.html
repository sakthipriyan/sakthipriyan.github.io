<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Financial Tools | Sakthi Priyan H</title>
    <meta name="description" content="Systems that Scale. Wealth that Compounds.">

    
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/reveal.js@4.3.1/dist/reveal.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/reveal.js@4.3.1/dist/theme/sky.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/reveal.js@4.3.1/plugin/highlight/monokai.css">

    
    <style>
         
        html, body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
        }

        .reveal {
            width: 100vw !important;
            height: 100vh !important;
        }

        .reveal section {
            font-size: 1.4em;
            line-height: 1.5;
        }

        .reveal .slides>section>section {
            font-size: 1.0em;
        }

        .reveal .progress {
            position: fixed;
            height: 12px;
            bottom: 10px;
            width: 90%;
            left: 5%;
            border-radius: 6px;
        }

        .graphviz {
            width: 100%;
            height: 80vh;
            text-align: center;
        }

        .graphviz svg {
            width: 100%;
            height: 100%;
            display: block;
        }

         
        pre code.dot,
        pre.language-dot,
        pre.dot {
            display: none;
        }

         
        .echarts-container {
            width: 100%;
            height: 80vh;
        }

         
        .gsap-fade-in {
            opacity: 0;
        }

        .gsap-slide-in {
            transform: translateX(-50px);
            opacity: 0;
        }
    </style>

    
</head>

<body>
    
<div class="reveal">
    <div class="slides">
        <section data-markdown data-separator="^---$" data-separator-vertical="^--$" data-separator-notes="^Note:" data-charset="utf-8">
            <textarea data-template>&lt;small style=&#34;
  display:inline-block;
  background: linear-gradient(90deg, #f4b400, #fcd34d);
  color: white;
  padding: 4px 10px;
  border-radius: 6px;
  font-weight: 800;
&#34;&gt;
sakthipriyan.com/building-wealth
&lt;/small&gt;

## Sakthi Priyan H  
## Building Wealth
#### presenting  &lt;!-- .element: class=&#34;fragment&#34; --&gt;

--

## Financial Tools  

### needed for Building Wealth  
#### Nov 02, 2025  &lt;!-- .element: class=&#34;fragment&#34; --&gt;
--

### Disclaimer
&lt;!-- .slide: data-autoslide=&#34;5000&#34; --&gt;
|  |  |
| --------------------------- | ---------------------------------------------------------- |
| **Personal Fit**      | Strategies shared reflect my experience and comfort level. |
| **Purpose**     | For learning and awareness, not financial advice.          |
| **Risk**         | Market values fluctuate; capital is always at risk.        |
| **Rules**         | Verify local tax and investment regulations.               |
| **Responsibility** | Make informed choices that align with your goals.          |

---

### Contents

1. Cash &amp; Bank Accounts  
2. Insurance 
3. Investments  
  a. Equity  
  b. Hybrid &amp; Debt  
  c. Gold  
  d. Real Assets  
4. Credit Cards &amp; Loans
5. Summary  

---

### 1. Cash &amp; Bank Accounts

**Purpose:** Liquidity and easy access ğŸ’§  

|  |  |  |
|------|--------------|---------|
| Bank Accounts | For salary credit, bill payments and daily expenses | ğŸŸ¢&amp;nbsp;Continue |
| Cash in Hand | Limited non-digital usage | ğŸŸ¡&amp;nbsp;Minimal |
| FD/RD | Used once; very tax inefficient | ğŸ”´&amp;nbsp;Exited |

&gt; ğŸ’¡ Keeps money flowing smoothly for expenses.

---

### 2. Insurance

**Purpose:** Risk management, not returns ğŸ›¡ï¸  

|  |  |  |
|------|--------------|---------|
| Health | Covers hospitalization &amp; health-related expenses | ğŸŸ¢&amp;nbsp;Continue |
| Term / Accident | Protects dependents in case of untimely demise | ğŸŸ¢&amp;nbsp;Continue |
| Motor | Mandatory for all vehicles | ğŸŸ¢&amp;nbsp;Continue |
| Home | Protects property &amp; belongings | ğŸŸ¡&amp;nbsp;Optional |

&gt; ğŸ’¡ First line of defense for **Building Wealth.**

---

### 3 Investments

**Purpose:** ğŸ“ˆ Long-term growth for building wealth  

--
#### 3a. Equity

|  |  |  |
|------|--------------|---------|
| Index Funds | Low-cost, broad-market | ğŸŸ¢&amp;nbsp;Continue |
| Active Funds | Higher cost, inconsistent | ğŸŸ¡&amp;nbsp;Paused |
| Demat Account | For direct equity holdings | ğŸŸ¡&amp;nbsp;Paused |
| US Equity | Global diversification via International Broker | ğŸŸ¢&amp;nbsp;Continue |

&gt; ğŸ“ˆ Grow wealth by owning businesses.

--

#### 3b. Hybrid &amp; Debt
|  |  |  |
|------|--------------|---------|
| Arbitrage Funds | Short-term parking for travel/medical corpus | ğŸŸ¢&amp;nbsp;Continue |
| Debt/Hybrid Funds | Used in the past; paused post-tax change | ğŸŸ¡&amp;nbsp;Paused |
| Debt Mutual Funds | Reduced benefit after Apr 2023 taxation | ğŸŸ¡&amp;nbsp;Paused |

&gt; ğŸ’° Debt funds provide steady income and lower volatility.


--
#### 3b. Hybrid &amp; Debt / Retirement
|  |  |  |
|------|--------------|---------|
| PPF | Long-term, government-backed, tax-efficient savings | ğŸŸ¢&amp;nbsp;Continue |
| EPF | Mandatory for salaried; offers tax-free compounding | ğŸŸ¡&amp;nbsp;Minimum |
| NPS | Limited flexibility and withdrawal constraints | ğŸŸ¡&amp;nbsp;Minimum |

&gt; ğŸ’¡ Provides long-term stability and retirement-focused growth.

--

#### 3c. Gold

**Purpose:** Inflation hedge, diversification and jewellery ğŸ’  

|  |  |  |
|------|--------------|---------|
| Gold ETF | Preferred for future investments â€” lower cost | ğŸŸ¢&amp;nbsp;Planned |
| Gold Mutual Fund | Existing investment, held for diversification | ğŸŸ¡&amp;nbsp;Paused |
| Physical Gold | Minimal jewellery holding as required | ğŸŸ¡&amp;nbsp;Minimal |

&gt; ğŸ’¡ Acts as a portfolio stabilizer.

--

#### 3d. Real Assets

**Purpose:** Tangible assets for utility and lifestyle ğŸ   

|  |  |  |
|------|--------------|---------|
| House | Primary residence with potential appreciation | ğŸŸ¡&amp;nbsp;Minimal |
| Vehicle | Utility, not investment; manage depreciation sensibly | ğŸŸ¡&amp;nbsp;Minimal |

&gt; ğŸ’¡ Offers stability, but comes with ongoing costs.

---

### 4. Credit Cards &amp; Loans

**Purpose:** Smart leverage and cash-flow management ğŸ’³  

|  |  |  |
|------|--------------|---------|
| Credit Cards | Use responsibly for rewards and short-term credit | ğŸŸ¢&amp;nbsp;Continue |
| Loans | Avoid for consumption; consider only for appreciating assets | ğŸŸ¡&amp;nbsp;Minimal |

&gt; ğŸ’¡ *Use credit but, donâ€™t let it use you.*

---

### 5. Summary
```dot
digraph FinancialTools {
  rankdir=TB;
  bgcolor=transparent;
  graph [fontsize=12, fontname=&#34;Arial&#34;];
  node [shape=box, style=&#34;rounded,filled&#34;, fontname=&#34;Arial&#34;, fontsize=11, fillcolor=&#34;#ffffff&#34;];
  edge [color=&#34;#666666&#34;];

  /* Central Node */
  core [label=&#34;ğŸ¦ Financial Tools&#34;, shape=box, style=&#34;filled&#34;, fillcolor=&#34;#f7f7f7&#34;, fontsize=13];

  /* Categories */
  liquid [label=&#34;ğŸ’§ Liquid&#34;, fillcolor=&#34;#eaf6ff&#34;];
  insurance [label=&#34;ğŸ›¡ï¸ Insurance&#34;, fillcolor=&#34;#effaf0&#34;];
  investments [label=&#34;ğŸ“ˆ Investments&#34;, fillcolor=&#34;#fff4e6&#34;];
  credit [label=&#34;ğŸ’³ Credit&#34;, fillcolor=&#34;#f0fbfb&#34;];

  /* Core Connections */
  core -&gt; liquid;
  core -&gt; insurance;
  core -&gt; investments;
  core -&gt; credit;

  /* Liquid Subnodes */
  cash [label=&#34;ğŸ’µ Cash&#34;];
  bank [label=&#34;ğŸ¦ Bank Accounts&#34;];
  liquid -&gt; cash;
  liquid -&gt; bank;

  /* Insurance Subnodes */
  medical [label=&#34;ğŸ¥ Medical&#34;];
  term [label=&#34;ğŸ›¡ï¸ Term&#34;];
  vehicle [label=&#34;ğŸš— Vehicle&#34;];
  insurance -&gt; medical;
  insurance -&gt; term;
  insurance -&gt; vehicle;

  /* Investments Cluster */
  subgraph cluster_investments {
    color=&#34;#f4b400&#34;;
    style=&#34;rounded,dashed&#34;;
    fontname=&#34;Arial&#34;;
    fontsize=11;
    margin=10;

    /* Equity */
    index [label=&#34;ğŸ“Š Equity Index Funds&#34;];
    index_in [label=&#34;ğŸ‡®ğŸ‡³ India&#34;];
    index_us [label=&#34;ğŸ‡ºğŸ‡¸ US&#34;];
    index -&gt; index_in;
    index -&gt; index_us;

    /* Debt &amp; Hybrid */
    arbitrage [label=&#34;âš–ï¸ Arbitrage Fund&#34;];
    debt [label=&#34;ğŸ’¼ Debt / Hybrid Funds&#34;];

    /* Gold */
    gold [label=&#34;ğŸ¥‡ Gold ETF&#34;];

    /* Retirement-like */
    ppf [label=&#34;ğŸ—ï¸ PPF&#34;];
  }

  /* Investment connections */
  investments -&gt; index;
  investments -&gt; gold;
  investments -&gt; debt;
  debt -&gt; arbitrage;
  debt -&gt; ppf;

  /* Credit Subnodes */
  creditcard [label=&#34;ğŸ’³ Credit Cards&#34;];
  credit -&gt; creditcard;
}
```

---

&lt;section data-autoslide=&#34;1000&#34;&gt;
  &lt;h2&gt;Sakthi Priyan H&lt;/h2&gt;
  &lt;h2&gt;Building Wealth&lt;/h2&gt;
  &lt;h4 class=&#34;fragment&#34; data-fragment-index=&#34;1&#34;&gt;Thank you! ğŸ‰&lt;/h4&gt;&lt;br/&gt;&lt;br/&gt;
  &lt;span class=&#34;fragment&#34; data-fragment-index=&#34;2&#34;&gt;Found this helpful? ğŸ’¡&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;
  &lt;span class=&#34;fragment&#34; data-fragment-index=&#34;3&#34;&gt;
    ğŸ‘ Like &amp; ğŸ’¬ Share with friends &amp; family!&lt;br/&gt;
    ğŸ“Œ Subscribe for more videos.
  &lt;/span&gt;&lt;br/&gt;
&lt;/section&gt;
</textarea>
        </section>
    </div>
</div>


    
    
    <script src="https://cdn.jsdelivr.net/npm/reveal.js@4.3.1/dist/reveal.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/reveal.js@4.3.1/plugin/markdown/markdown.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/reveal.js@4.3.1/plugin/highlight/highlight.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/reveal.js@4.3.1/plugin/notes/notes.js"></script>
    
    
    
    
    
    
    
    
    <script src="https://cdn.jsdelivr.net/npm/viz.js@2.1.2/viz.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/viz.js@2.1.2/full.render.js"></script>
    
    
    
    
    
    

    

        
<script>
    let isInitialLoad = true;
    
    
    function renderGraphviz(slide = null) {
        const slides = slide ? [slide] : Array.from(Reveal.getSlides());
        slides.forEach(slideEl => {
            slideEl.querySelectorAll('pre code.dot, pre.language-dot, pre.dot').forEach(codeEl => {
                if (codeEl.dataset.rendered) return;

                const dotCode = codeEl.textContent.replace(/&gt;/g, '>').replace(/&lt;/g, '<');
                console.log('[DEBUG] Rendering DOT block:\n', dotCode);

                const viz = new Viz();
                viz.renderSVGElement(dotCode)
                    .then(svg => {
                        
                        svg.removeAttribute('width');
                        svg.removeAttribute('height');
                        svg.setAttribute('preserveAspectRatio', 'xMidYMid meet');

                        
                        const container = document.createElement('div');
                        container.className = 'graphviz';
                        container.appendChild(svg);

                        
                        const preEl = codeEl.parentNode;
                        preEl.parentNode.replaceChild(container, preEl);

                        codeEl.dataset.rendered = true;
                        console.log('[DEBUG] Diagram rendered and pre replaced.');
                    })
                    .catch(err => {
                        console.error('[DEBUG] Viz.js error:', err);
                        codeEl.parentNode.textContent = "Error rendering diagram: " + err;
                    });
            });
        });
    }

    
    function initializeECharts(slide = null) {
        if (typeof echarts === 'undefined') return;
        
        
        if (slide) {
            
            requestAnimationFrame(() => {
                requestAnimationFrame(() => {
                    slide.querySelectorAll('.echarts-container[data-chart]').forEach(container => {
                        console.log('[DEBUG] Processing chart container:', container.id, 'has instance:', !!container._chartInstance);
                        
                        
                        if (container._chartInstance) {
                            console.log('[DEBUG] Disposing existing chart instance:', container.id);
                            container._chartInstance.dispose();
                            container._chartInstance = null;
                        }
                        
                        try {
                            const config = JSON.parse(container.dataset.chart);
                            
                            console.log('[DEBUG] Creating new chart instance:', container.id);
                            
                            
                            
                            let chart = echarts.getInstanceByDom(container);
                            
                            if (chart) {
                                console.log('[DEBUG] Found existing ECharts instance, disposing it:', container.id);
                                chart.dispose();
                                chart = null;
                            }
                            
                            
                            container.innerHTML = '';
                            
                            
                            chart = echarts.init(container);
                            
                            
                            chart.setOption(config, true);
                            
                            
                            container._chartInstance = chart;
                            container.dataset.initialized = true;
                            
                            
                            setTimeout(() => chart.resize(), 100);
                            
                            console.log('[DEBUG] ECharts initialized with animation:', container.id);
                        } catch (err) {
                            console.error('[DEBUG] ECharts error:', err);
                        }
                    });
                });
            });
        } else {
            
            const currentSlide = Reveal.getCurrentSlide();
            if (currentSlide) {
                initializeECharts(currentSlide);
            }
        }
        
        
        window.removeEventListener('resize', handleChartResize);
        window.addEventListener('resize', handleChartResize);
    }
    
    function handleChartResize() {
        document.querySelectorAll('.echarts-container[data-initialized]').forEach(container => {
            if (container._chartInstance) {
                container._chartInstance.resize();
            }
        });
    }

    
    function triggerGSAPAnimations(slide) {
        if (typeof gsap === 'undefined') {
            console.log('[DEBUG] GSAP not loaded');
            return;
        }
        if (!slide) {
            console.log('[DEBUG] No slide provided to triggerGSAPAnimations');
            return;
        }
        
        
        requestAnimationFrame(() => {
            requestAnimationFrame(() => {
                
                document.querySelectorAll('[data-gsap]').forEach(el => {
                    delete el.dataset.gsapAnimated;
                    
                    gsap.set(el, { clearProps: "all" });
                });
                
                
                const elements = slide.querySelectorAll('[data-gsap]');
                console.log('[DEBUG] Found', elements.length, 'elements with data-gsap on current slide');
                
                elements.forEach(el => {
                    if (el.dataset.gsapAnimated) return;
                    
                    try {
                        const config = JSON.parse(el.dataset.gsap);
                        console.log('[DEBUG] Animating element with config:', config);
                        
                        
                        const { from, ...options } = config;
                        const animationVars = { ...from, ...options };
                        
                        gsap.from(el, animationVars);
                        el.dataset.gsapAnimated = true;
                        console.log('[DEBUG] GSAP animation triggered for element:', el);
                    } catch (err) {
                        console.error('[DEBUG] GSAP error:', err);
                    }
                });
            });
        });
    }

    document.addEventListener('DOMContentLoaded', function() {
        Reveal.initialize({
            hash: true,
            plugins: [RevealMarkdown, RevealHighlight, RevealNotes],
            transition: 'slide',
            slideNumber: false,
            margin: 0.05,
            width: "100%",
            height: "100%",
            minScale: 1,
            maxScale: 1,
            progress: true
        });

        
        Reveal.addEventListener('ready', event => {
            console.log('[DEBUG] Reveal ready, rendering all slides...');
            
            Reveal.getSlides().forEach(slideEl => {
                if (slideEl.dataset.parsed) return;
                if (slideEl.querySelector('textarea[data-template]')) {
                    RevealMarkdown.parseSlide(slideEl);
                    slideEl.dataset.parsed = true;
                }
            });
            renderGraphviz(); 
            triggerGSAPAnimations(event.currentSlide); 
            
        });

        
        Reveal.on('slidechanged', event => {
            console.log('[DEBUG] Slide changed to index', event.indexh);
            
            
            if (event.previousSlide) {
                event.previousSlide.querySelectorAll('.echarts-container[data-chart]').forEach(container => {
                    if (container._chartInstance) {
                        console.log('[DEBUG] Disposing chart on previous slide:', container.id);
                        container._chartInstance.dispose();
                        container._chartInstance = null;
                        container.innerHTML = '';
                        delete container.dataset.initialized;
                    }
                });
            }
            
            
            renderGraphviz(event.currentSlide);
            triggerGSAPAnimations(event.currentSlide);
            
            
            setTimeout(() => {
                initializeECharts(event.currentSlide);
            }, 300);
        });

        
        Reveal.addEventListener('markdown', event => {
            console.log('[DEBUG] Markdown parsed for slide', event.slide);
            renderGraphviz(event.slide);
            
        });
    });
</script>


            <script>
            
            (function() {
                function getQueryParam(name) {
                    return new URLSearchParams(window.location.search).get(name);
                }
                const obsParam = getQueryParam('obs');
                if (obsParam) {
                    
                    const parts = obsParam.split(":");
                    let host = parts[0] || "";
                    let port = parts[1] || "";
                    let password = "";
                    if (parts.length > 2) {
                        
                        password = parts.slice(2).join(":");
                    }
                    if (!host || !port) {
                        host = prompt("Enter OBS host (e.g. 192.168.1.100):", "localhost") || "localhost";
                        port = prompt("Enter OBS port (e.g. 4455):", "4455") || "4455";
                    }
                    const obsWsUrl = `ws://${host}:${port}`;

                    
                    var obsScript = document.createElement('script');
                    obsScript.src = 'https://cdn.jsdelivr.net/npm/obs-websocket-js';
                    obsScript.onload = function() {
                        const obs = new OBSWebSocket();

                        const connectToObs = async () => {
                            try {
                                await obs.connect(obsWsUrl, password);
                                console.log('Connected to OBS!');
                                
                                
                                try {
                                    const { scenes } = await obs.call('GetSceneList');
                                    obsScenes = scenes.map(scene => scene.sceneName).reverse();
                                    console.log('Available OBS scenes:', obsScenes);
                                    
                                    if (obsScenes.length === 0) {
                                        console.warn('No scenes found in OBS, using default scenes');
                                        obsScenes = ["Screen Only", "Video RB", "Video Only"];
                                    }
                                    
                                    
                                    const { currentProgramSceneName } = await obs.call('GetCurrentProgramScene');
                                    obsSceneIndex = obsScenes.indexOf(currentProgramSceneName);
                                    if (obsSceneIndex === -1) obsSceneIndex = 0;
                                    console.log(`Current scene: ${currentProgramSceneName}, index: ${obsSceneIndex}`);
                                } catch (error) {
                                    console.error('Failed to fetch scenes from OBS:', error);
                                    obsScenes = ["Screen Only", "Video RB", "Video Only"];
                                }
                            } catch (error) {
                                console.error('Failed to connect:', error);
                            }
                        };

                        const switchScene = async (sceneName) => {
                            try {
                                await obs.call('SetCurrentProgramScene', { sceneName });
                                console.log(`Switched to scene: ${sceneName}`);
                            } catch (error) {
                                console.error('Failed to switch scene:', error);
                            }
                        };

                        connectToObs();

                        let obsSceneIndex = 0;
                        let obsScenes = ["Screen Only", "Video RB", "Video Only"]; 

                        document.addEventListener("keydown", (e) => {
                            const key = e.key;
                            if (key != "b" && key != "Escape" && key != "Shift" &&
                                    key != "F5" && key != "Alt" && key != "Meta" && key != "Ï€") {
                                    return;
                            }
                            e.preventDefault();
                            e.stopImmediatePropagation();
                            if (key === "b") {
                                    obsSceneIndex = (obsSceneIndex - 1 + obsScenes.length) % obsScenes.length;
                            } else if (key === "Escape" || key === "Ï€") {
                                    obsSceneIndex = (obsSceneIndex + 1) % obsScenes.length;
                            }
                            if (key === "b" || key === "Escape" || key === "Ï€") {
                                    const currentScene = obsScenes[obsSceneIndex];
                                    switchScene(currentScene);
                            }
                        }, true);
                    };
                    document.body.appendChild(obsScript);
                }
            })();
            </script>
                <script async src="https://www.googletagmanager.com/gtag/js?id=G-5NGEJ767SK"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'G-5NGEJ767SK');
    </script>
</body>

</html>